# TrackPy Helper

---

## General

### Description

- **Version:** beta
- **Author:** Vivien WALTER
- **Contact:** walter.vivien@gmail.com

**TPHelper** is a Python 3.x module acting as a wrapper for the module [TrackPy](http://soft-matter.github.io/trackpy/v0.4.2/).

### Compatibility

For maximum compatibility, it is recommended to use the module [microImage](https://github.com/vivien-walter/microImage) to generate the image arrays.

---

## Table of contents

- [Installation](#install)
  - [Requirements](#required)
  - [Installation using the setup.py script](#script)
- [How-to use the module](#howto)
  1. [Optimisation of the detection parameters](#settings)
    1. [Starting a session](#start)
    2. [Functions from TrackPy](#trackpy)
    3. [Displaying and managing the attributes](#attributes)
    4. [Quick display of the result](#preview)
    5. [Saving and loading the settings](#save)
  2. [Tracks management](#manager)
    1. [Initialising the manager](#init)
    2. [Listing and indexing tracks](#index)
    3. [Duplicating the instance](#duplicate)
    4. [Tracks modifications](#edit)
    5. [Displaying the trajectory](#display)
    6. [Extracting the trajectory from the manager](#extract)

---

## Installation <a name="install"></a>

### Requirements <a name="required"></a>

The following modules are required to run TPHelper:

- TrackPy
- NumPy
- Pandas
- microImage

TPHelper is not able to install microImage automatically. You will have to install it manually first. You can follow the instructions on [microImage](https://github.com/vivien-walter/microImage) page.

If you install the module using the setup.py script, you do NOT need to install first the other modules above.

### Installation using the setup.py script <a name="script"></a>

1. Download the module folder on the github repo

- Installation in a **Terminal-based** environment

  2. Open a terminal in the module folder
  3. (Opt.) Start your virtualenv if you use one
  4. Type and run the command
    ```bash
  python3 setup.py install
  ```

- Installation in an **Anaconda** environment

  2. Open Anaconda and go to your Environments
  3. Select the environment you want to install the module into
  4. Click on the arrow next to the name of the environment and select Open a Terminal
  5. Navigate to the module folder
  6. Type and run the command
    ```bash
  python setup.py install
  ```

---

## How-to use the module <a name="howto"></a>

The **examples/** folder provides a .py script as well as a Jupyter notebook to use TPHelper.

### 1 - Optimisation of the detection parameters <a name="settings"></a>

The detection of features in an image is handled by a class **TrackingSession**. This class holds all the parameters commonly used by TrackPy, and can save and/or load a file containing all these settings.

#### 1a - Starting a session <a name="start"></a>

To start a detection session, the function *startSession()* should be called:

```python
import TPHelper as tph

tpSettings = tph.startSession(dark_spots=False, diameter=11)
```

The arguments `dark_spots=` and `diameter=` defines the general characteristics of the objects to be detected on the image. Dark spots should be made true if the points are darker than the backgroud, and diameter is the approximate size of the objects.

It is possible to start a session by directly load a setting file or an image array. For this, the arguments `load_file=` and `array=` can respectively be called.

The element returned by this function is an object with the following attributes:

Name | Type | Description
---|---|---
`session.array` | 2 or 3-D array | (Opt.) Image array to be used directly by the class functions. Dimensions are (Y,X) for 2-D arrays or (Nbr of frames,Y,X) for 3-D ones.
`session.trajectory` | Pandas DataFrame | (Opt.) DataFrame generated by TrackPy, containing the positions and informations on all objects detected in the image(s).
`session.raw_trajectory` | Pandas DataFrame | (Opt.) Raw version of the DataFrame above, for fast application of filters.

All other attributes are copies of the parameters from the TrackPy functions [tp.locate](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.locate.html#trackpy.locate), [tp.batch](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.batch.html#trackpy.batch), [tp.link](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.link.html#trackpy.link) and [tp.filtering.filter_stubs](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.filtering.filter_stubs.html#trackpy.filtering.filter_stubs). Details on the attributes can be found in the respective API pages.

To avoid redundancy in the names of the attributes, the following arguments have been renamed in the class

From | Original name | TrackingSession name | Type | Description
--- | --- | --- | --- | ---
tp.filtering.filter_stubs | `threshold` | `session.filter_stubs` | Int | Minimum number of points (video frames) to survive.

#### 1b - Functions from TrackPy <a name="trackpy"></a>

The following functions from TrackPy are included in the class instance:

- `tp.locate()`

The function *locate()* detects objects on a single frame. It is a convenient tool to preview the current settings before running the *batch()* function on all frames.

```python
trajectory = tpSettings.locate()
```

The function will return a pandas DataFrame containing the location and informations of all the objects detected by TrackPy. This function will uses as arguments for the *tp.locate()* function all the attributes of the TrackingSession instance.

The TrackingSession *locate()* function uses three optional arguments: (i) the argument `array=` can be used to specify on which image array the function should be run. If not used, the function will look for the image in `session.array`. (ii) the argument `frame=` is used with 3-D arrays to specify the frame to be processed (default: 0). Finally, (iii) the argument `store=True` can be used to also store the result of the detection in the class instance itself, in `session.raw_trajectory` and `session.trajectory`.

- `tp.batch()`

The function *batch()* takes the same arguments as the function *locate()* but scan all the frames of a 3-D image array.

```python
trajectory = tpSettings.batch()
```

As compared to the function *locate()*, *batch()* has an additional argument `filter=True` to directly connect and filter the detected trajectory. If set to False, the trajectory will be saved in both attributes `session.raw_trajectory` and `session.trajectory`. If True, the trajectory will only be saved to `session.raw_trajectory` and the filtered trajectory, using the function *filter()* (cf. below), will be stored in `session.trajectory`.

- `tp.link()` and `tp.filtering.filter_stubs()`

Connection of trajectories (`tp.link()`) and filtering of spurious tracks  (`tp.filtering.filter_stubs()`) can be both called by the function *filter()*

```python
trajectory = tpSettings.filter()
```

This function will uses as arguments for the tp.link() and tp.filtering.filter_stubs() functions all the attributes of the TrackingSession instance. The function tp.filtering.filter_stubs() will only be called if the attribute `session.filter_stubs` is different from None type.

The TrackingSession *filter()* function uses two optional arguments: (i) the argument `dataframe=` can be used to specify on which image array the function should be run. If not used, the function will look for the image in `session.raw_trajectory`. (ii) The argument `store=True` can be used to also store the result of the detection in the class instance itself, in `session.trajectory`.

#### 1c - Displaying and managing the attributes <a name="attributes"></a>

The TrackingSession instance will contain all the parameters needed for the TrackPy functions. To modify the attributes of the instance, one should simply assign new value to the attributes, e.g.

```python
tpSettings.diameter = 41
```

It is possible to display the values of all parameters and/or of only one parameters with its description. This can be done with the two following functions:

- `session.showParameters()`

The function *showParameters()* will display the list of all the attributes of the instance with their current value.

```python
tpSettings.showParameters(group_by=True)
```

The argument `group_by=` allows the user to print either a one column list (False) or a structured 2-columns list (True).

- `session.showDescription()`

The function *showDescription()* will display the current value of the selected parameter along with the description from TrackPy API.

```python
tpSettings.showDescripton('memory')
```

The name of the parameter should be the same as the one from the class attribute. You can use the function showParameters() to display all the names of all attributes.

#### 1d - Quick display of the result <a name="preview"></a>

The result of the particle and/or trajectory detection can be displayed anytime using the *preview* function.

```python
tpSettings.preview(array=imageArray, dataframe=trajectory, frame=None, show_frame=10)
```

Depending on the input, the function will either display the whole trajectory or the detected object on a single frame (if `array=` is a 2-D array, if `dataframe=` does not include multiple frames or if `frame=` is different from None type). When a full trajectory is displayed, the argument `show_frame=` is used to select which frame of the sequence should be shown with the paths.

If `array=` or `dataframe=` are not used, the function will automatically look for the attributes `session.array` and `session.trajectory`.

#### 1e - Saving and loading the settings <a name="save"></a>

The TrackingSession class allows for a quick and easy option to save all the settings currently in memory in a single .json file. This file can be loaded later in another session to analyse another array with similar parameters, or to start setting up a new analysis from a similar point.

The settings can be saved with the function *.save()*

```python
tpSettings.save(file_name='experiment.json')
```

Only .json extension can be use here. If `file_name=` is not used, the function will generate a file using the date and time.

The .json files can be loaded using the function *.load()*

```python
tpSettings.load('experiment.json')
```

Alternatively, the session can be directly start by loading a .json file, such as

```python
import TPHelper as tph

tpSettings = tph.startSession(load_file='experiment.json')
```

In this case, the new session will directly have all the settings from the .json loaded and ready to be used.

### 2 - Tracks management <a name="manager"></a>

Management of tracks generated by TrackPy is handled by a class **TrackManager**. This class holds a collection of function that can be used to facilitate working and editing the paths of objects in an image sequence.

#### 2a - Initialising the manager <a name="init"></a>

To start the manager, the function *startManager()* should be called:

```python
import TPHelper as tph

tracksEdition = tph.startManager(dataframe, array=imageArray)
```

The dataframe loaded as an argument should be a DataFrame generated by TrackPy directly. The array containing the corresponding image sequence can be loaded in the argument `array=` to make the display functions easier to call, but is optional.

The element returned by this function is an object with the following attributes:

Name | Type | Description
---|---|---
`manager.trajectory` | Pandas DataFrame | DataFrame generated by TrackPy, containing the positions and informations on all objects detected in the image(s).
`manager.array` | 2 or 3-D array | (Opt.) Image array to be used directly by the class functions. Dimensions are (Y,X) for 2-D arrays or (Nbr of frames,Y,X) for 3-D ones.

#### 2b - Listing and indexing tracks <a name="index"></a>

Tracks in the DataFrame can be listed using the function *listTracks()*

```python
tracksEdition.listTracks()
```

The function just return the list of all the (unique) tracks number (`particle` column in the DataFrame).

The track numbers can be reset to a standard increasing list of indices (0,1,2,...) using the function *resetID()*

```python
tracksEdition.resetID()
```

It is recommended to follow the function resetID() by the function listTracks() to check that the modification worked.

#### 2c - Duplicating the instance <a name="duplicate"></a>

At any time, the whole TrackManager instance - and the DataFrame and array included inside - can be duplicated into a new instance using the function *duplicate()*

```python
tracksCopy = tracksEdition.duplicate()
```

This allows for backup while editing further with advanced functions.

#### 2d - Tracks modifications <a name="edit"></a>

The class can be used to edit the tracks with various functions

- **Merging tracks**

Two tracks can be merged into a single one in case TrackPy missed a connection between two frames. This can be done by the function *merge()*

```python
track1_id = 2
track2_id = 10
tracksEdition.merge(track1_id, track2_id)
```

The list of IDs of the tracks can be obtained with the function *listTracks()* (see above). In case both tracks have positions detected in the same frame, the positions and characteristic from the 1st track will be kept.

- **Splitting track**

A track can be split into two tracks at a given frame using the function *split()*

```python
track_id = 5
split_after_frame = 10
tracksEdition.split(track_id, split_after_frame)
```

The position on the given frame will be saved with the positions of the points before this frame. The ID of the new track (ie after the given frame) will be equal to the number after the max ID of the current list of tracks.

- **Removing track**

A track can be deleted from the trajectory DataFrame using the function *remove()*

```python
track_id = 6
tracksEdition.remove(track_id)
```

It is not possible to recover the deleted track. It is therefore recommended to create a backup using the *duplicate()* function (see above).

#### 2e - Displaying the trajectory <a name="display"></a>

The TrackManager class can simply display the trajectory using the *show()* function.

```python
tracksEdition.show(track_ids=[0,3,4], array=None, show_frame=10, frame=None)
```

If not set to None, `track_ids=` can be used to display only the tracks in the list.

Depending on the input, the function will either display the whole trajectory or the detected object on a single frame (if `array=` is a 2-D array, if the DataFrame in memory does not include multiple frames or if `frame=` is different from None type). When a full trajectory is displayed, the argument `show_frame=` is used to select which frame of the sequence should be shown with the paths.

If `array=` is not used, the function will automatically look for the attributes `manager.array`.

#### 2f - Extracting the trajectory from the manager <a name="extract"></a>

The class offers several possibilities to extract the trajectories after processing

- **Extract a trajectory with only the selected particles**

It can be sometimes convenient to only keep a reduced number of tracks from a DataFrame. The function *extract()* can be use to generate a new TrackPy DataFrame with only the selected tracks.

```python
newTrajectory = tracksEdition.extract(track_ids=[1,5,10], as_dataframe=True)
```

If `as_dataframe=` is False, the returned structure is a list of numpy arrays.

- **Save the trajectory in a file**

Once edited, the trajectory can be saved into a file using the *save()* function

```python
tracksEdition.save(file_name='trajectory.xml', track_ids=None)
```

The file can either be exported as a .XML file, or as a comma-separated value format (.TXT, .CSV or .DAT).

To select only a reduced number of tracks, the `track_ids=` argument can be used. If left equal to None type, all tracks will be saved.
