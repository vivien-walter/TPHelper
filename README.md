# TrackPy Helper

---

## General

### Description

- **Version:** 1.0
- **Author:** Vivien WALTER
- **Contact:** walter.vivien@gmail.com

**TPHelper** is a Python 3.x module acting as a wrapper for the module [TrackPy](http://soft-matter.github.io/trackpy/v0.4.2/).

### Compatibility

For maximum compatibility, it is recommended to use the module [microImage](https://github.com/vivien-walter/microImage) to generate the image arrays.

---

## Table of contents

- [Installation](#install)
  - [Requirements](#required)
  - [Installation using the setup.py script](#script)
- [How-to use the module](#howto)
  1. [Optimisation of the detection parameters](#settings)
    * [Starting a session](#start)
    * [Functions from TrackPy](#trackpy)
    * [Displaying and managing the attributes](#attributes)
    * [Quick display of the result](#preview)
    * [Saving and loading the settings](#save)
  2. [Tracks management](#manager)
    * [Initialising the manager](#init)
    * [Listing and indexing tracks](#index)
    * [Duplicating the instance](#duplicate)
    * [Tracks modifications](#edit)
    * [Displaying the trajectory](#display)
    * [Intensity measurements](#intensity)
    * [Extracting the trajectory from the manager](#extract)
  3. [Functions for track analysis](#functions)
    * [Extract intensity profiles](#func_profile)
    * [Calculate signal properties](#func_signal)
    * [Compute integrated intensity](#func_integration)

---

## Installation <a name="install"></a>

### Requirements <a name="required"></a>

The following modules are required to run TPHelper:

- TrackPy
- NumPy
- Pandas
- microImage

TPHelper is not able to install microImage automatically. You will have to install it manually first. You can follow the instructions on [microImage](https://github.com/vivien-walter/microImage) page.

If you install the module using the setup.py script, you do NOT need to install first the other modules above.

### Installation using the setup.py script <a name="script"></a>

1. Download the module folder on the github repo

- Installation in a **Terminal-based** environment

  2. Open a terminal in the module folder
  3. (Opt.) Start your virtualenv if you use one
  4. Type and run the command
    ```bash
  python3 setup.py install
  ```

- Installation in an **Anaconda** environment

  2. Open Anaconda and go to your Environments
  3. Select the environment you want to install the module into
  4. Click on the arrow next to the name of the environment and select Open a Terminal
  5. Navigate to the module folder
  6. Type and run the command
    ```bash
  python setup.py install
  ```

---

## How-to use the module <a name="howto"></a>

The **examples/** folder provides a .py script as well as a Jupyter notebook to use TPHelper.

### 1 - Optimisation of the detection parameters <a name="settings"></a>

The detection of features in an image is handled by a class **TrackingSession**. This class holds all the parameters commonly used by TrackPy, and can save and/or load a file containing all these settings.

#### 1a - Starting a session <a name="start"></a>

To start a detection session, the function *startSession()* should be called:

```python
import TPHelper as tph

tpSettings = tph.startSession(input=microImageObject, dark_spots=False, diameter=11)
```

The TPHelper session can be directly initialized with an image array or with a microImage instance using the argument `input=`. When using a microImage instance, the session will automatically extract all relevant informations and data from the instance.

The arguments `dark_spots=` and `diameter=` defines the general characteristics of the objects to be detected on the image. Dark spots should be made true if the points are darker than the backgroud, and diameter is the approximate size of the objects.

It is possible to start a session by directly load a setting file. For this, the arguments `load_file=` can be called.

The element returned by this function is an object with the following attributes:

Name | Type | Description
---|---|---
`session.input` | 2 or 3-D array, ImageStack instance | (Opt.) Image array or microImage ImageStack instance to be used directly by the class functions. For array, dimensions are (Y,X) for 2-D arrays or (Nbr of frames,Y,X) for 3-D ones.
`session.tracks` | Pandas DataFrame | (Opt.) DataFrame generated by TrackPy, containing the positions and informations on all objects detected in the image(s).
`session.spots` | Pandas DataFrame | (Opt.) Raw version of the DataFrame above, for fast application of filters.

All other attributes are copies of the parameters from the TrackPy functions [tp.locate](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.locate.html#trackpy.locate), [tp.batch](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.batch.html#trackpy.batch), [tp.link](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.link.html#trackpy.link) and [tp.filtering.filter_stubs](http://soft-matter.github.io/trackpy/v0.4.2/generated/trackpy.filtering.filter_stubs.html#trackpy.filtering.filter_stubs). Details on the attributes can be found in the respective API pages.

To avoid redundancy in the names of the attributes, the following arguments have been renamed in the class

From | Original name | TrackingSession name | Type | Description
--- | --- | --- | --- | ---
tp.filtering.filter_stubs | `threshold` | `session.filter_stubs` | Int | Minimum number of points (video frames) to survive.

#### 1b - Functions from TrackPy <a name="trackpy"></a>

The following functions from TrackPy are included in the class instance:

- `tp.locate()`

The function *locate()* detects objects on a single frame. It is a convenient tool to preview the current settings before running the *batch()* function on all frames.

```python
trajectory = tpSettings.locate()
```

The function will return a pandas DataFrame containing the location and informations of all the objects detected by TrackPy. This function will uses as arguments for the *tp.locate()* function all the attributes of the TrackingSession instance.

The TrackingSession *locate()* function uses four optional arguments: (i) the argument `input=` can be used to specify on which image array or microImage instance the function should be run. If not used, the function will look for the image in `session.input`. (ii) the argument `frame=` is used with image stacks to specify the frame to be processed (default: 0). (iii) the argument `store=True` can be used to also store the result of the detection in the class instance itself, in `session.spots` and `session.tracks`. Finally, (iv) the boolean argument `raw_input=` can be used to switch between calculation on the corrected image or not when the input is a microImage instance.

- `tp.batch()`

The function *batch()* takes the same arguments as the function *locate()* but scan all the frames of a 3-D image array.

```python
trajectory = tpSettings.batch()
```

As compared to the function *locate()*, *batch()* has an additional argument `filter=True` to directly connect and filter the detected trajectory. If set to False, the trajectory will be saved in both attributes `session.spots` and `session.tracks`. If True, the trajectory will only be saved to `session.spots` and the filtered trajectory, using the function *filter()* (cf. below), will be stored in `session.tracks`.

- `tp.link()` and `tp.filtering.filter_stubs()`

Connection of trajectories (`tp.link()`) and filtering of spurious tracks  (`tp.filtering.filter_stubs()`) can be both called by the function *filter()*

```python
trajectory = tpSettings.filter()
```

This function will uses as arguments for the tp.link() and tp.filtering.filter_stubs() functions all the attributes of the TrackingSession instance. The function tp.filtering.filter_stubs() will only be called if the attribute `session.filter_stubs` is different from None type.

The TrackingSession *filter()* function uses two optional arguments: (i) the argument `dataframe=` can be used to specify on which image array the function should be run. If not used, the function will look for the image in `session.spots`. (ii) The argument `store=True` can be used to also store the result of the detection in the class instance itself, in `session.tracks`.

#### 1c - Displaying and managing the attributes <a name="attributes"></a>

The TrackingSession instance will contain all the parameters needed for the TrackPy functions. To modify the attributes of the instance, one should simply assign new value to the attributes, e.g.

```python
tpSettings.diameter = 41
```

It is possible to display the values of all parameters and/or of only one parameters with its description. This can be done with the two following functions:

- `session.showParameters()`

The function *showParameters()* will display the list of all the attributes of the instance with their current value.

```python
tpSettings.showParameters(group_by=True)
```

The argument `group_by=` allows the user to print either a one column list (False) or a structured 2-columns list (True).

- `session.showDescription()`

The function *showDescription()* will display the current value of the selected parameter along with the description from TrackPy API.

```python
tpSettings.showDescripton('memory')
```

The name of the parameter should be the same as the one from the class attribute. You can use the function showParameters() to display all the names of all attributes.

#### 1d - Quick display of the result <a name="preview"></a>

The result of the particle and/or trajectory detection can be displayed anytime using the *preview* function.

```python
tpSettings.preview(input=imageArray, dataframe=trajectory, frame=None, show_frame=10)
```

Depending on the input, the function will either display the whole trajectory or the detected object on a single frame (if `input=` is a single frame, if `dataframe=` does not include multiple frames or if `frame=` is different from None type). When a full trajectory is displayed, the argument `show_frame=` is used to select which frame of the sequence should be shown with the paths.

If `input=` or `dataframe=` are not used, the function will automatically look for the attributes `session.input` and `session.tracks`. The argument `raw_input=` can be used to specify if calculation should be done on the non-corrected input or not.

#### 1e - Saving and loading the settings <a name="save"></a>

The TrackingSession class allows for a quick and easy option to save all the settings currently in memory in a single .json file. This file can be loaded later in another session to analyse another array with similar parameters, or to start setting up a new analysis from a similar point.

The settings can be saved with the function *.save()*

```python
tpSettings.save(file_name='experiment.json')
```

Only .json extension can be use here. If `file_name=` is not used, the function will generate a file using the date and time.

The .json files can be loaded using the function *.load()*

```python
tpSettings.load('experiment.json')
```

Alternatively, the session can be directly start by loading a .json file, such as

```python
import TPHelper as tph

tpSettings = tph.startSession(load_file='experiment.json')
```

In this case, the new session will directly have all the settings from the .json loaded and ready to be used.

### 2 - Tracks management <a name="manager"></a>

Management of tracks generated by TrackPy is handled by a class **TrackManager**. This class holds a collection of function that can be used to facilitate working and editing the paths of objects in an image sequence.

#### 2a - Initialising the manager <a name="init"></a>

To start the manager, the function *startManager()* should be called:

```python
import TPHelper as tph

tracksEdition = tph.startManager(dataframe, display_input=imageArray)
```

The dataframe loaded as an argument should be a DataFrame generated by TrackPy directly. Alternatively, the TrackManager can be started with a TrackingSession as an input. The array or microImage instance containing the corresponding image sequence for display purpose can be loaded in the argument `display_input=` to make the display functions easier to call, but is optional. If not specified, the function will try to extract it from the main input.

The element returned by this function is an object with the following attributes:

Name | Type | Description
---|---|---
`manager.positions` | Pandas DataFrame, TrackingSession instance | DataFrame generated by TrackPy or TrackingSession instance, containing the positions and informations on all objects detected in the image(s).
`manager.display` | 2 or 3-D array, ImageStack instance | (Opt.) Image array or microImage ImageStack instance to be used directly by the class functions. Dimensions for the array are (Y,X) for 2-D arrays or (Nbr of frames,Y,X) for 3-D ones.

#### 2b - Listing and indexing tracks <a name="index"></a>

Tracks in the DataFrame can be listed using the function *listTracks()*

```python
tracksEdition.listTracks()
```

The function just return the list of all the (unique) tracks number (`particle` column in the DataFrame).

The track numbers can be reset to a standard increasing list of indices (0,1,2,...) using the function *resetID()*

```python
tracksEdition.resetID()
```

It is recommended to follow the function resetID() by the function listTracks() to check that the modification worked.

#### 2c - Duplicating the instance <a name="duplicate"></a>

At any time, the whole TrackManager instance - and the DataFrame and array included inside - can be duplicated into a new instance using the function *duplicate()*

```python
tracksCopy = tracksEdition.duplicate()
```

This allows for backup while editing further with advanced functions.

#### 2d - Tracks modifications <a name="edit"></a>

The class can be used to edit the tracks with various functions

- **Merging tracks**

Two tracks can be merged into a single one in case TrackPy missed a connection between two frames. This can be done by the function *merge()*

```python
track1_id = 2
track2_id = 10
tracksEdition.merge(track1_id, track2_id)
```

The list of IDs of the tracks can be obtained with the function *listTracks()* (see above). In case both tracks have positions detected in the same frame, the positions and characteristic from the 1st track will be kept.

- **Splitting track**

A track can be split into two tracks at a given frame using the function *split()*

```python
track_id = 5
split_after_frame = 10
tracksEdition.split(track_id, split_after_frame)
```

The position on the given frame will be saved with the positions of the points before this frame. The ID of the new track (ie after the given frame) will be equal to the number after the max ID of the current list of tracks.

- **Removing track**

A track can be deleted from the trajectory DataFrame using the function *remove()*

```python
track_id = 6
tracksEdition.remove(track_id)
```

It is not possible to recover the deleted track. It is therefore recommended to create a backup using the *duplicate()* function (see above).

#### 2e - Displaying the trajectory <a name="display"></a>

The TrackManager class can simply display the trajectory using the *show()* function.

```python
tracksEdition.show(track_ids=[0,3,4], display_input=None, show_frame=10, frame=None)
```

If not set to None, `track_ids=` can be used to display only the tracks in the list.

Depending on the input, the function will either display the whole trajectory or the detected object on a single frame (if `display_input=` is a 2-D array, if the DataFrame in memory does not include multiple frames or if `frame=` is different from None type). When a full trajectory is displayed, the argument `show_frame=` is used to select which frame of the sequence should be shown with the paths.

If `display_input=` is not used, the function will automatically look for the attributes `manager.display`. In any case, the argument `raw_input=` can be used with a microImage instance to select the non-corrected image or not.

#### 2f - Intensity measurements <a name="intensity"></a>

The TrackManager class can be used to directly analyse the intensity of the image on the positions of the tracks detected. An extensive description of the function is given in the section [Functions for track analysis](#functions).

- **Compute the profiles of intensity on each position of the given tracks**

The command *intensityProfile()* will extract the profile of intensity on all given positions.

```python
tracksEdition.intensityProfile(tracks_ids=[0,1,2], profile_type='radial', space_scale=46.21)
```

The Manager will automatically load the trajectory from itself. A specific stack array can be given for the calculation using the `array=` argument. If not specified, the Manager will look in itself to search for a microImage instance.

All the other arguments of this command are similar to the command of the function [intensityProfile()](#func_profile) described below.

- **Convert profiles into measurements of signal, noise and SNR**

The profiles of intensity collected with the command *intensityProfile()* can be converted into standard measurements of the contrast, noise and signal-to-noise ratio, using the *signalProperties()* command.

```python
tracksEdition.signalProperties(profiles=profileIntensity, use_fit=True)
```

The `profiles=` argument should strictly take an output of the *intensityProfile()* command or function. If this argument is not specified, the command will automatically call the *intensityProfile()* command. It therefore uses the same arguments, although only the 'gaussian' and 'sinc' values can be picked for the `profile_type=` argument.

All the other arguments of this command are similar to the command of the function [signalProperties()](#func_signal) described below.

- **Integrate the intensity of each point**

The profiles of intensity collected with the command *intensityProfile()* can be converted into integrated intensity measurements using the *integratedProfile()* command.

```python
tracksEdition.integratedProfile(profiles=profileIntensity, use_fit=True)
```

The `profiles=` argument should strictly take an output of the *intensityProfile()* command or function. If this argument is not specified, the command will automatically call the *intensityProfile()* command. It therefore uses the same arguments, although only the 'gaussian' and 'sinc' values can be picked for the `profile_type=` argument.

All the other arguments of this command are similar to the command of the function [integrateProfile()](#func_integration) described below.

#### 2g - Extracting the trajectory from the manager <a name="extract"></a>

The class offers several possibilities to extract the trajectories after processing

- **Extract a trajectory with only the selected particles**

It can be sometimes convenient to only keep a reduced number of tracks from a DataFrame. The function *extract()* can be use to generate a new TrackPy DataFrame with only the selected tracks.

```python
newTrajectory = tracksEdition.extract(track_ids=[1,5,10], as_dataframe=True)
```

If `as_dataframe=` is False, the returned structure is a list of numpy arrays.

- **Save the trajectory in a file**

Once edited, the trajectory can be saved into a file using the *save()* function

```python
tracksEdition.save(file_name='trajectory.xml', track_ids=None)
```

The file can either be exported as a .XML file, or as a comma-separated value format (.TXT, .CSV or .DAT).

To select only a reduced number of tracks, the `track_ids=` argument can be used. If left equal to None type, all tracks will be saved.

### 3 - Functions for track analysis <a name="functions"></a>

In addition to the two classes used to manage TrackPy functions and output, the module TPHelper includes a serie of functions to analyse the images based on the track collected.

#### 3a - Extract intensity profiles <a name="func_profile"></a>

The intensity of the image can be collected along the tracks found by TrackPy. This is done using the function *intensityProfile()*.

```python
import TPHelper as tph

profiles = tph.intensityProfile(positions, input=imageArray, track_ids=[0,1,2],
  scan_window=62, profile_type='line', line_angle=45, space_scale=46.21)
```

The `position` should be an output of the TrackPy function *link()*, or an instance from any class of TPHelper. The `input=` argument is used to specify the array on which the intensity will be calculated. It can be directly a numpy array of a microImage instance.

The list of tracks to analyse can be selected using the `track_ids=` argument. If left equal to None, all tracks will be analysed.

To make most process faster, a scanning window can be specified using `scan_window=`. Value can either be an int or tuple of int. If the particle position is too close to the edge of the image, the window size will automatically be recalculated.

Several options can be selected for the type of profiling to calculate, all using the argument `profile_type=`:

* `profile_type="spot"`: The function will return a single numerical value for each position, corresponding to the intensity on the given pixel position.

* `profile_type="mean"`, `="median"` or `="std"`: The function will return a single numerical value for each position, corresponding to the selected statistical moment selected of all pixels in the scanning window.

* `profile_type="line"`: The function will return two arrays, one containing the pixel values along a line crossing the scanning window, and the corresponding distances from the position measured by TrackPy. The angle of the line with the X-axis can be selected using the argument `line_angle=` with a value in degrees.

* `profile_type="radial"`: The function will return two arrays similar to the ones from the `="line"` option. But instead of collecting the pixel values along a single line, the function will do a radial profile average of all pixel values at each distance d from the center.

* `profile_type="gaussian"` or `="sinc"` : The function will return two arrays similar to the ones from the `="line"` option, but the intensity will correspond to the fit of the measured one using the given function. The type of measurement for the profile to be fitted can be selected between line and radial using the `fit_type=` argument. The number of points making the fitted profile can chosen with the `n_points=` argument. The type of signal (dark or bright particle) should be specified using the `dark_spots=` argument.

If a space scale is given using the `space_scale=` argument, two arrays will be returned for each *distance* array : one in pixel units and the other with the given unit.

The output of this function is a dictionary of dictionaries for each tracks given. The dictionary of the elements of each frame can be accessed using the ID of the track as a key

```python
profile_for_track_nbr10 = profiles[10]
```

The profile dictionary of a given track has the following keys, each containing an array of the value for each analysed frame:

* **'position'**: the (Y,X) coordinates measured by trackpy.

* **'frame'**: the list of frames on which positions have been measured by trackpy.

* **'intensity'**: the intensities measured using the selected profiling type.

* **'distance'**: the distances corresponding to each position at which intensities have been measured. Only for types line, radial, gaussian and sinc.

* **'distance_px'**: the distances given in pixel units, only if a space scale has been given. In this case, the 'distance' array above will be given in the unit specified with the space scale.

* **'raw_intensity'**: the intensities measured on the image which have been used to generate the fit. In this case, the 'intensity' array above will be the one of the fitted intensity. Only for types gaussian and sinc.

* **'raw_distance'** and **'raw_distance_px'**: the distances measured on the image which have been used to generate the fit. In this case, the 'distance' and 'distance_px' arrays above will be the ones of the fitted intensity.

* **'parameters'**: fit parameters measured for the corresponding profile. The four parameters are (in order): amplitude, center, width and offset. Only for types gaussian and sinc.

* **'errors'**: fit errors measured for the corresponding profile.

#### 3b - Calculate signal properties <a name="func_signal"></a>

The intensity profiles extracted with the function *intensityProfile()* can be converted into measurements of the contrast of the signal, noise of the image and signal-to-noise ratio of the point. This is done by the function *signalProperties()*

```python
import TPHelper as tph

properties = tph.signalProperties(profiles, use_fit=True, dark_spots=False, fit_type='gaussian')
```

The value of the contrast can be measured on the raw or on the fitted profile. The choice is made using the `use_fit=` boolean argument. If no fit has been done to collect the profiles used in the input, the function will automatically fit the profiles using the options given by the arguments `fit_type=` and `dark_spots=`.

The output will be a dictionary of dictionaries for each tracks given, similar to the one from the function *intensityProfile()*, but with only three keys for each track dictionary:

* **'contrast'**: array with the contrast measured on each frame.

* **'noise'**: array with the noise measured on each frame.

* **'snr'**: array with the signal-to-noise ratios measured on each frame.

#### 3c - Compute integrated intensity <a name="func_integration"></a>

The intensity profiles extracted with the function *intensityProfile()* can also be converted into measurements of the integrated intensity of the spot using the *integrateProfile()* function.

```python
import TPHelper as tph

integrations = tph.integrateProfile(profiles, use_fit=True, dark_spots=False, fit_type='gaussian')
```

The value of the integration can be measured on the raw or on the fitted profile. The choice is made using the `use_fit=` boolean argument. If no fit has been done to collect the profiles used in the input, the function will automatically fit the profiles using the options given by the arguments `fit_type=` and `dark_spots=`.

The output will be a dictionary for each track, each key containing the array of integrated intensity for the given track ID.
